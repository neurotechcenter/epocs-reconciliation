The ReflexConditioningSignalProcessing module consists of 6 processing stages (referred to in BCI2000 parlance as "filters" although note that this term can mean something more specific when we talk about digital filtering).  Each stage has an associated .cpp and .h file.  Some of these are, and should remain, very generic.  In other words, their functionality is not limited to ReflexConditioningSignalProcessing nor to any one particular scientific purpose. Changes motivated by one specific scientific context should NOT be made in IIRBandpass (which is part of the general BCI2000 signal-processing framework library), nor in NIDAQFilter (which is managed as part of a contributed SignalSource module), nor in Trapfilter and SharedMemoryOutputConnector (although these were custom-written for the ReflexConditioningSignalProcessing purposes, their function is very generic so they may be incorporated into the BCI2000 framework libraries in future).  By contrast, the functions of RangeIntegrator, and in particular BackgroundTriggerFilter, are specific to the ReflexConditioningSignalProcessing context---tweaks to your experiment might be made here if they are related to the existing mission of these filters, or by adding new filters if not.

IIRBandpass (generic - part of BCI2000 framework - do not hack here)

	This is a component of the BCI2000 signal-processing framework library. Its purpose is to apply high-pass, low-pass and notch digital filters to the incoming signal as part of the signal-processing pipeline. In ReflexConditioningSignalProcessing, this component is generally used purely for its high-pass filter.  Note that filters are applied indiscriminately to all channels including trigger channels.  This has an advantage for the processing of timing (any group delay introduced by the filters will then be common to both trigger and bio-signal) but may have undesirable side-effects if the low-pass or notch filters are enabled (the rising edge of the trigger pulse will no longer be sharp).
	
	
BackgroundTriggerFilter (custom - specific to the context of triggering stimulation contingent on background EMG activity - hack here if necessary and if relevant to this context)
	
	This filter monitors the level of activity in one or more channels, and issues a message (i.e. sets the EnableTrigger state variable to 1) whenever the activity has remained within a specified range for a specified amount of time. Its purpose in ReflexConditioningSignalProcessing is to make delivery of a stimulus (peripheral electrical pulse or TMS pulse) contingent on the desired level of background EMG activity.
	
NIDAQFilter (contributed - part of the contributed NIDAQ_mx_Source module - do not hack here)
	
	This filter was originally introduced as part of the NIDAQ_mx_Source module for National Instruments data acquisition boards, and its source code is still managed together with other NI-specific components of that contributed module. In contrast to the NIDAQLogger and NIADC components, the NIDAQFilter controls the generation of digital and/or analog *output* signals from a National Instruments board. We use it to respond to the EnableTrigger state variable and generate an actual physical trigger pulse.
	
	It is unusual to include such a hardware-specific component in a BCI2000 SignalProcessing module. By including it here, we have compromised the usual modularity of the BCI2000 system, so that migrating one's experiment to different hardware would no longer be just a case of swapping out the SignalSource module. However, there is a good reason for adopting this approach.   BCI2000 operation happens in cycles, and a batch of data called a SampleBlock is acquired by the DataIOFilter at the beginning of each cycle. If hardware-specific code were confined to the SignalSource module, as is more conventional, it would be executed *after* the DataIOFilter waits for the incoming SampleBlock but *before* the BackgroundTriggerFilter in the same cycle. So, between evaluation of the background EMG to decide whether to trigger stimulation, and actual stimulation, we would have to wait for the next SampleBlock to arrive (typically this is set to 40--50 msec). This is unacceptable because stimulation is intended to be very closely and precisely contingent on very recent EMG state.  So, instead, we insert NIDAQFilter directly after BackgroundTriggerFilter in the chain. With this arrangement, the gap between the last sample included in the evaluation that leads to a trigger, and the sample on which the trigger voltage is actually detected, is 2 to 3 milliseconds.  Luckily, the NIDAQmx API allows multiple processes to access the hardware simultaeously (in our case, the SignalSource module NIDAQ_mx_Source and the SignalProcessing module ReflexConditioningSignalProcessing)---it is not clear to what extent this would be possible with other hardware (for example, the gUSBamp).
	
TrapFilter (generic - could be used for many BCI2000 applications - avoid hacking here)


RangeIntegrator (custom - somewhat specific to the context of evaluating the magnitude of time-locked EMG responses - hack here if absolutely necessary)

SharedMemoryOutputConnector  (generic - could be used for many BCI2000 applications - avoid hacking here)
