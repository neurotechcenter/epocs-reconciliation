
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN"
    "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
      xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
      xmlns:dc="http://purl.org/dc/elements/1.1/"
      xmlns:foaf="http://xmlns.com/foaf/0.1/">
  <head>
        <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="theme.css" />
      <title>
        Structure of the ReflexConditioningSignalProcessing Module
      </title>
  </head>
  <body>
  <img src="logo.png" width="100%" />
<h1>Structure of the ReflexConditioningSignalProcessing Module</h1>
<p>The core functions of EPOCS are implemented by a custom version of the BCI2000 software platform. Specifically, the real-time logic of background EMG monitoring, stimulus triggering, reflex computation and conditioning is handled by a custom BCI2000 signal-processing module called <code>ReflexConditioningSignalProcessing</code>.</p>
<p>The <code>ReflexConditioningSignalProcessing</code> module consists of 6 processing stages. These stages are referred to in BCI2000 parlance as "filters" (bear this in mind to avoid confusion with the more conventional, more specific meaning of the term "filter" in digital signal processing).  Each stage has an associated <code>.cpp</code> and <code>.h</code> file.  Some of these are, and should remain, very generic.  In other words, their functionality is not limited to <code>ReflexConditioningSignalProcessing</code> nor to any one particular scientific purpose. Changes motivated by one specific scientific context should <strong>not</strong> be made in <code>IIRBandpass</code> (which is part of the general BCI2000 signal-processing framework library). Nor should such changes be made in <code>NIDAQFilter</code> (which is managed as part of a contributed BCI2000 SignalSource module). Nor should they be made in <code>Trapfilter</code> and <code>SharedMemoryOutputConnector</code> (although these were custom-written for the <code>ReflexConditioningSignalProcessing</code> purposes, their function is very generic so they may be incorporated into the BCI2000 framework libraries in future).  By contrast, the functions of <code>RangeIntegrator</code>, and in particular <code>BackgroundTriggerFilter</code>, are specific to the <code>ReflexConditioningSignalProcessing</code> context—tweaks to your experiment might be made here if they are related to the existing mission of these filters, or by adding new filters if not.</p>
<p>As for all BCI2000 signal-processing modules, the identity and ordering of the filters is defined by the module's <a href="http://doc.bci2000.org/Programming_Tutorial%3aImplementing_a_Signal_Processing_Filter#Filter_instantiation"><code>PipeDefinition.cpp</code></a> file. This is configured as follows:</p>
<h2>1. <a href="http://doc.bci2000.org/User_Reference%3aIIRBandpass">IIRBandpass</a></h2>
<p><em>(generic - part of BCI2000 framework - do not hack here)</em></p>
<p>This is a component of the BCI2000 signal-processing framework library. Its purpose is to apply causal digital high-pass, low-pass and notch filters to the incoming signal as part of the signal-processing pipeline. In <code>ReflexConditioningSignalProcessing</code>, this component is generally used purely for its high-pass filter. (Even when using amplifiers that supposedly perform high-pass filtering, we found that the digitized data often had a considerable DC offset, and it is important to remove this before computing absolute EMG amplitudes.) Note that filters are applied indiscriminately to all channels including trigger channels.  This has an advantage for the processing of timing (any group delay introduced by the filters will then be common to both trigger and bio-signal) but may have undesirable side-effects if the low-pass or notch filters are enabled (the rising edge of the trigger pulse might no longer be sharp).</p>
<p>For full documentation of this filter, see the entry <a href="http://doc.bci2000.org/User_Reference%3aIIRBandpass">User_Reference:IIRBandpass</a> on the BCI2000 wiki.</p>
<h2>2. <a href="BackgroundTriggerFilter.html">BackgroundTriggerFilter</a></h2>
<p><em>(custom - specific to the context of triggering stimulation contingent on background EMG activity - hack here if necessary and if relevant to this context)</em></p>
<p>This filter monitors the level of activity in one or more channels, and issues a message (i.e. sets the <code>EnableTrigger</code> state variable to 1) whenever the activity has remained within a specified range for a specified amount of time. Its purpose in <code>ReflexConditioningSignalProcessing</code> is to make delivery of a stimulus (peripheral electrical pulse or TMS pulse) contingent on the desired level of background EMG activity. The filter also computes in real time a one-dimensional indicator of muscle activity, in the <code>BackgroundFeedbackValue</code> state variable, to be relayed to the patient (in the <a href="EPOCSGUI.html">EPOCS GUI</a>, this is then rendered as the height of the "Background" bar); finally the filter keeps track of whether the muscle activity is currently inside or outside the required range (according to which the <a href="EPOCSGUI.html">EPOCS GUI</a> turns the bar green or red, respectively) in the <code>BackgroundGreen</code> state variable.</p>
<p>For full documentation on this filter, see the <a href="BackgroundTriggerFilter.html">BackgroundTriggerFilter</a> page.</p>
<h2>3. <a href="http://doc.bci2000.org/Contributions%3aNIDAQFilter">NIDAQFilter</a></h2>
<p><em>(contributed - part of the contributed NIDAQ_mx_Source module - do not hack here)</em></p>
<p>This filter was introduced into the <code>contrib</code> section of the BCI2000 distribution, as part of the <code>NIDAQ_mx_Source</code> module for National Instruments data acquisition boards. The <code>NIDAQFilter</code> source code is still managed together with other NI-specific components of that contributed module. In contrast to the <code>NIDAQLogger</code> and <code>NIADC</code> components which deal with digital and analog inputs to a National Instruments board, the <code>NIDAQFilter</code> controls the generation of digital and/or analog <em>output</em> signals from the board. We use it to respond to the <code>EnableTrigger</code> state variable and generate a physical trigger pulse.</p>
<p>It is unusual to include such a hardware-specific component in the SignalProcessing module of a BCI2000 system. By including it here, we have compromised BCI2000's usual modularity, with the result that migrating one's experiment to different hardware would no longer be just a case of swapping out the SignalSource module. However, there is a good reason for adopting this approach, as follows.   BCI2000 operation happens in cycles. At the beginning of each cycle, the <code>DataIOFilter</code> waits until sufficient samples are available from the signal acquisition hardware. It then sends these samples (together called a SampleBlock) to subsequent filters. If the hardware-specific <code>NIDAQFilter</code> code were confined to the SignalSource module, as is conventional, it would be executed <em>after</em> the <code>DataIOFilter</code> waits for the incoming SampleBlock but <em>before</em> the <code>BackgroundTriggerFilter</code> in the same cycle. Therefore, between evaluation of the background EMG to decide whether to trigger the stimulation, and actual stimulation, we would have to wait until the <em>next</em> cycle's SampleBlock to arrive. Typically the <code>SampleBlockSize</code> parameter is set such that this happens every 40–50 msec. This delay is unacceptable because stimulation is intended to be very closely and precisely contingent on very recent EMG states.  So, instead, we insert <code>NIDAQFilter</code> directly after <code>BackgroundTriggerFilter</code> in the chain. With this arrangement, the gap between the last sample included in the evaluation that leads to a trigger, and the sample on which the trigger voltage is actually detected, is 2 to 3 milliseconds.  Luckily, the NIDAQmx API makes this possible by allowing multiple processes to access the hardware simultaneously (in our case, the SignalSource module <code>NIDAQ_mx_Source</code> and the SignalProcessing module <code>ReflexConditioningSignalProcessing</code>). It is not clear to what extent this would be possible with other hardware (for example, the gUSBamp).</p>
<p>For full documentation of this filter, see the entry <a href="http://doc.bci2000.org/Contributions%3aNIDAQFilter">Contributions:NIDAQFilter</a> on the BCI2000 wiki.</p>
<p>To make it work in <code>ReflexConditioningSignalProcessing</code>, we use the following command-line options in our BCI2000 launcher script <code>app/batch/run-nidaqmx.bat</code>:</p>
<pre><code>start executable ReflexConditioningSignalProcessing --local --NumberOfThreads=1 --LogDigiOut=Dev1-000000010000000000000000 --LogAnaOut=Dev1-10
</code></pre>

<p>Both the <code>--LogDigiOut</code> and <code>--LogAnaOut</code> flags assume that our NI board is registered as the first NIDAQmx device, <code>Dev1</code>.  The <code>--LogDigiOut</code> flag assumes that our board has 24 digital outputs and specifies that we will use the 8th of these (which the NI API calls <code>/port0/line7</code>) as our first output. The <code>--LogAnaOut</code> flag assumes that our board has 2 analog outputs and specifies that we will use the first of these (which the NI API calls <code>/ao0</code>) as our second output.</p>
<p>We then configure the filter's <code>FilterExpressions</code> parameter as follows in our BCI2000 parameter file <code>app/parms/base-nidaqmx.prm</code>:</p>
<pre><code>Filtering     matrix     FilterExpressions= { Dev1/port0/line7 Dev1/ao0 } 1   EnableTrigger 5000000*EnableTrigger
</code></pre>

<p>The row labels <code>Dev1/port0/line7</code> and <code>Dev1/a0</code> are for the user's information only:  really it is the order of the entries that determines which information is output where.  The digital output is set equal to the value of the <a href="BackgroundTriggerFilter.html">BackgroundTriggerFilter</a>'s <code>EnableTrigger</code> state variable, which can be 0 or 1.  The analog output is set equal to <code>5000000</code> microvolts times the value of <code>EnableTrigger</code>, i.e. either 0V or 5V.   The digital and the analog output redundantly perform the same job. It is better to use the digital output, provided you have made the appropriate custom wiring connection (see the <a href="HardwareDocumentation.html">hardware documentation</a>).</p>
<p>Ideally, the NIDAQFilter would be redesigned so that it does not require command-line switches ("logging" in the BCI2000 sense is not necessary to its functionality).  Instead, it should use an expression matrix with two columns:  the NI API address (like <code>Dev1/port0/line7</code>) and the expression.  The NI API would then not be used if the parameter was left empty, and would first be contacted during <code>Preflight</code> and <code>Initialize</code> rather than during filter construction.  This would allow EPOCS to be customized for a wider range of NI boards (e.g. those that are not called <code>Dev1</code>, or those that have a number of digital+analog outputs other than 24+2) purely by changing to BCI2000 parameters. This could then be done gracefully in a <a href="Customization.html">custom script</a>.  As it stands, such changes can only be performed using an ugly hack to the <code>start executable ReflexConditioningSignalProcessing</code> line, which is likely to lead to version-control conflicts.   Unfortunately, such changes to the NIDAQFilter code would have to be done delicately to avoid breaking backward compatibility—as at 2014-07-31, this has not yet been possible.</p>
<h2>4. <a href="TrapFilter.html">TrapFilter</a></h2>
<p><em>(generic - could be used for many BCI2000 applications - avoid hacking here)</em></p>
<p>This filter makes BCI2000 behave like an externally triggered storage oscilloscope.  It monitors a specified trigger channel, and waits for a trigger event - i.e. a time-sample on which the signal value in the trigger channel exceeds a specified threshold. The filter collects the signal from the channels of interest for a specified period before and after the trigger event, and outputs this signal segment statically until the next trigger event occurs.  In the <code>ReflexConditioningSignalProcessing</code> module, the purpose of this is to collect the EMG signal epoch that is time-locked to each particular stimulus. To do this, it relies on the physical trigger pulse (generated by the previous filter) being physically fed back into the digitizer as an extra signal channel.</p>
<p>For full documentation on this filter, see the <a href="TrapFilter.html">TrapFilter</a> page.</p>
<h2>5. <a href="RangeIntegrator.html">RangeIntegrator</a></h2>
<p><em>(custom - somewhat specific to the context of evaluating the magnitude of time-locked EMG responses - hack here if absolutely necessary)</em></p>
<p>The purpose of this filter is to compute the magnitudes of evoked responses. It operates on the time-locked epoch data delivered by the <code>TrapFilter</code>. It defines an arbitrary number of "responses", each of which is computed by integrating over specified time intervals (relative to the trigger pulse) in specified channels.  It defines a weighting across these responses and uses this to compute a one-dimensional feedback value, in the state variable <code>ResponseFeedbackValue</code>, that can then be relayed to the patient (in the <a href="EPOCSGUI.html">EPOCS GUI</a>, this is rendered as the height of the "Response" bar).  The <code>ResponseIntegrator</code> also defines a set of conditions (lower and/or upper bounds) that the response magnitudes must satisfy for the trial to be considered successful. It keeps track of whether the last trial was successful or not, which it stores in the <code>ResponseGreen</code> state variable (and according to which the <a href="EPOCSGUI.html">EPOCS GUI</a> turns the response bar green or red, respectively) and also keeps a running count of successful trials in the <code>SuccessfulTrials</code> state variable. </p>
<p>For full documentation on this filter, see the <a href="RangeIntegrator.html">RangeIntegrator</a> page.</p>
<h2>6. <a href="SharedMemoryOutputConnector.html">SharedMemoryOutputConnector</a></h2>
<p><em>(generic - could be used for many BCI2000 applications - avoid hacking here)</em></p>
<p>The purpose of this filter is inter-process communication (IPC) - specifically, to transfer signal data and state variables to another process in real time. In <code>ReflexConditioningSignalProcessing</code> it serves to transfer information to the <a href="EPOCSGUI.html">EPOCS GUI</a> which runs in Python.  The use cases for this filter are generally similar to those for BCI2000's standard <a href="http://doc.bci2000.org/User_Reference%3aConnectorOutput">ConnectorOutput</a> filter, which uses a UDP socket connection for the same purpose, but the UDP socket was found to have insufficient bandwidth for current purposes. (Note: the actual bandwidth required is low in principle, since the GUI only needs to update the height and color of the "Background" bar in real time; the more detailed EMG signal information need only be transferred once per trial. However, to take advantage of this would have required a major departure from BCI2000's synchronous mode of operation in favor of an asynchronous model. It was easier to continue with the synchronous model, i.e. to let <code>TrapFilter</code> output the full 2-channel 1920-sample epoch on <em>every</em> 40-msec SampleBlock and to transfer this to the GUI <em>completely</em> within the time allotted for a single SampleBlock whenever a new trial occurred.)</p>
<p>For full documentation on this filter, see the <a href="SharedMemoryOutputConnector.html">SharedMemoryOutputConnector</a> page.</p>
  </body>
</html>
